# FrontEnd

- [함수형 프로그래밍이란?](#함수형-프로그래밍이란)
- [브라우저 저장소](#브라우저-저장소)
- [브라우저 동작 원리](#브라우저-동작-원리)
- [Virtual DOM이란? 썼을 때 장점](#Virtual-DOM)
- [Javascript의 this](#Javascript의-this)
- [Javascript의 prototype](#Javascript의-prototype)
- [Javascript event](#Javascript-event)
  (이벤트 캡처링 & 버블링, 이벤트 위임방식)
- [Javascript 비동기 처리](#Javascript-비동기-처리)
  (콜백, 프로미스, async-await)
- [프론트엔드 빌드 시스템](#프론트엔드-빌드-시스템)
- [웹팩이란? 모듈 번들러란?](#웹팩이란-모듈-번들러란)
- [웹 접근성과 시맨틱 마크업이란?](#웹-접근성과-시맨틱-마크업이란?)
- [프론트엔드 성능 최적화란?](#프론트엔드-성능-최적화)
- [CORS란? CORS를 해결하기 위한 방법](#CORS란)
- [MVC 패턴이란?](#MVC-패턴이란)
- [mvvm 모델이란?](#mvvm-모델이란)
- “기획 - 디자인 - API 개발 - 프런트엔드 개발”의 서비스 절차에서 프런트엔드 개발자의 역할은 무엇이라고 생각하는지?
- 웹 서비스 배포 시스템 구축시 CI, CD가 무엇인가?
- [Array와 LinkedList 차이점](#Array와-LinkedList-차이점)
- [타입스크립트란?(TypeScript)](#타입스크립트란)

<br></br>
<br></br>
<br></br>

# 함수형 프로그래밍이란

함수형 프로그래밍이란 하나의 선언형 프로그래밍 파러다임으로 정의되는 일련의 코딩 접근 방식입니다. 순수 함수를 조합하고 스프트웨어를 만드는 방식이라고 말할 수 있습니다.

순수 함수(pure function) 를 조합하고 공유 상태(shared state), 변경 가능한 데이터(mutable data) 및 부작용(side-effects) 을 피하여 소프트웨어를 만드는 프로세스다.명령형(imperative) 이 아닌 선언형(declarative) 이며 애플리케이션의 상태는 순수 함수를 통해 전달됩니다.
<br></br>
<br></br>

# 브라우저 저장소

### Web Storage

web storage란 HTML5부터 제공하는 기능으로 해당 도메인과 관련된 특정 데이터를 서버가 아니라 클라이언트 웹 브라우저에 저장할 수 있도록 제공하는 기능이다. 이와 비슷한 기능으로 쿠키(cookie)가 있다.

key/value 형태로 데이터를 저장하고 key를 기반으로 데이터를 조회하는 방식이다. 영구저장소라 불리기도 하는 LocalStorage와 임시저장소라 불리는 SessionStorage 두 곳이 있다. 데이터의 지속성을 구분할 수 있어 응용 환경에 맞는 선택이 가능하다.

web storage는 쿠키와 마찬가지로 사이트의 도메인 다윈로 접근이 제한된다. 예를 들면 A사이트에 저장한 데이터는 B사이트에서는 조회할 수 없다. 보안측면을 보자면 당연하다.

### 그렇다면 쿠키라는 것도 있는데 왜 web storage가 필요한가?

세가지 모두 브라우저에 저장되만 쿠키는 web storage와 비교해서

- 4KB의 데이터 저장 제한
- HTTP Request에 암호화 되지 않은 상태로 사용하기때문에 보안에 취약
- 쿠키는 모든 HTTP Request에 포함되어 웹 서비스 성능에 영향을 줄 수 있다

이런 차이가 있다.
<br></br>
이제 web storage가 쿠키에 비해서 가지는 강점에 대해 이야기해보자
쿠키는 매번 서버로 전송이 된다.

- web storage는 저장된 데이터가 클라이언트에 존재할 뿐 서버로 전송되지는 않는다. 이는 네트워크 트래픽 비용을 줄여준다.
- web storage는 문자열 기반 데이터 외에 체계적으로 구조화된 객체를 저장할 수 있다
- web storage는 용량의 제한이 없다. 클라이언트 최대 300개의 쿠키를 저장할 수 있고 용량이 제한되어있다.
- web storage는 영구 데이터 저장이 가능하다. 쿠키는 만료일자를 지정하게 되어있어 언젠가 제거된다. 만약에 만요일자를 지정하지 않으면 세션쿠키가 된다.

<br></br>
✔️ 세션쿠키(Session Cookie)
활성 웹 브라우저 세션이 있는 기간동안 저장된다. 세션쿠키는 일반적으로 웹 브라우저를 닫을 때 삭제된다.
<br></br>

### Web Storage

1. LocalStorage - 브라우저를 닫았다가 다시 열어도 계속 유지된다. 도메인마다 별도로 생성된다.
2. SessionStorage - 브라우저가 열려있는 한 페이지를 reload해도 계속 유지된다. 하지만 브라우저를 닫으면 삭제된다. 같은 사이트의 같은 도메인이라도 브라우저가 다르면 서로 다른 영역이 된다.
   <br></br>
   <br></br>

# 브라우저 동작 원리

브라우저가 HTML을 전달 받으면, 곧 이를 변환(파싱)하고 노드들로 이루어진 DOM 트리를 만든다. 이후 외부의 CSS파일과 각 노드들의 inline 스타일을 파싱하여 스타일을 입힌 Render트리를 만든다. Render트리가 만들엊면 각 노드들이 화면에서 정확히 어디에 나타나야 하는지에 대한 위치가 주어진다. 그 후, paint() 메서드를 호출하면 내가 구현하고 싶었던 화면이 출력된다. DOM은 해당 과정을 계속 반복한다.

- DOM Tree 생성 - Render Tree 생성 - Layout - Paint

<br></br>
현재 대부분의 웹사이트는 수 십개 혹은 수 백개의 페이지로 이루어져있다. 오타 하나를 잡고 싶을 뿐인데, 전체 사이트를 다시 처음부터 렌더링을 해야 하며, 그 수정할 부분을 찾는 시간도 많이 걸려서 굉장히 비효율적이다. 이 부분을 타파하기 위해서 Virtual DOM이 나왔다.
<br></br>
<br></br>
<br></br>

# Virtual DOM

그전에 DOM이란? 문서 객체 모델(The Document Object Model, 이하 DOM) 은 HTML, XML 문서의 프로그래밍 interface 입니다. DOM은 문서(HTML)의 구조화된 표현을 제공하며 프로그래밍 언어가 DOM 구조에 접근할 수 있는 방법을 제공하여 그들이 문서 구조, 스타일, 내용 등을 변경할 수 있게 돕는 역할을 합니다
웹브라우저까지 가는 진행 방향은~ 일단 HTML를 읽습니다. 객체들을 DOM tree에 생성 그리고 CSS 파일을 읽어서 CSSOM tree 생성 그 두 가지가 랜더링 되면서 브라우저에 표시가 됩니다.
이 때 DOM tree에 생성되는 node가 변경 될 때 마다 이 과정을 계속해서 새롭게 해야 하는데 이때 속도가 너무 느려집니다. 그래서 나온 게 virtual DOM!

일종의 DOM의 복사본 같은 게 virtual DOM인데 DOM조작에 의한 비효율적인 랜더링 문제, DOM 복잡도 증가에 따른 최적화 및 유지보수가 어려워지는 문제를 해결하기 위한 기술

- DOM의 가벼운 복사 본
- in-memory에 존재해서 실제 렌더 되지 않음
- JavaScript 객체로 이루어진 tree data structure
- React와 같은 UI 라이브러리에 널리 쓰임
  위와 같은 특징을 가지고 있습니다.

실제로 데이터가 업데이트되면 전체 UI를 virtual DOM에 리렌더링합니다. 그리고 DOM에 있는 내용과 자체적으로 비교를 하고 바뀐 부분만 실제 DOM에 적용시켜서 한번만 리랜더링이 일어나게 합니다.

Virtual DOM(가상 DOM)은 개발자가 작업을 보다 쉽게 할 수 있도록 도와주는 것이지, 가상돔에서 더 빠르게 접근할 수 있는 무언가를 제공해 주는 것이 아니다. 실제로 vanila.js가 가상돔에서 작업하는 것보다 항상 더 빠르다고 합니다. 가상돔은 목적을 위한 수단일 뿐이라는 점을 기억해야합니다!
<br></br>
<br></br>

# Javascript의 this

javascript에서 함수의 this의 값은 함수를 호출하는 방법에 의해 결정된다. 실행하는 동안의 할당에 의해 설정될 수 없고, 함수가 호출될 때 마다 다를 수 있다. ES5에는 함수의 this 값이 함수가 어떻게 호출되었는지 개의치 않고 설정할 수 있는 bind 메소드가 있다.

바인딩이란? this의 호출 방식에 따라서 this가 특정 '객체'에 연결되는 것이다. this 바인딩은 일반 함수 내부, 메소드 내부, 생성자 함수 내부, Call, Apply, Bind 를 통한 '호출 방식'으로 나눠서 볼 수 있다.

- 일반 함수 내부에서의 this는 글로벌 객체와 바인딩된다.
- 메서드 내부에서의 this는 메서드를 호출한 객체와 바인딩된다.
- 생성자 함수 내부에서 this는 생성자 함수가 생성할 인스턴스와 바인딩된다.
- call, apply, bind 메서드 사용시 메서드에 첫번째 인수로 전달하는 객체에 바인딩 된다. <br>
  [자세히 보러가기]

this는 함수 호출 방식에 따라서 동적으로 결정된다.
<br></br>
<br></br>

# Javascript의 prototype

자바스크립트의 모든 객체는 프로토타입이라는 객체를 가지고 있습니다. 모든 객체는 그들의 프로토 타입으로부터 프로퍼티와 메소드를 상속받습니다. 이처럼 자바스크립트의 모든 객체는 최소한 하나 이상의 다른 객체로부터 상속을 받으며, 이 때 상속되는 정보를 제공하는 객체를 프로토타입이라고 합니다.

- 프로토타입의 생성 <br/>
  프로토타입을 생성하는 가장 기본적인 방법은 객체 생성자 함수(object constructor function)를 작성하는 것입니다. 생성자 함수를 작성하고 new 연산자를 사용해 객체를 생성하면, 같은 프로토타입을 가지는 객체들을 생성할 수 있습니다. <br/>

        function Dog(color, name, age) {
          // 개에 관한 생성자 함수를 작성함.

         this.color = color;          // 색에 관한 프로퍼티
         this.name = name;            // 이름에 관한 프로퍼티
         this.age = age;              // 나이에 관한 프로퍼티
         }

         var myDog = new Dog("흰색", "마루", 1); // 이 객체는 Dog라는 프로토타입을 가짐.

         document.write("우리 집 강아지는 " + myDog.name + "라는 이름의 " + myDog.color + " 털이 매력적인 강아지입니다.");

<br></br>
<br></br>

# Javascript event

### 이벤트 캡쳐(Event Capture)

이벤트 캡쳐는 클릭 이벤트가 발생한 지점을 찾아 내려가는 이벤트 전파 방식입니다. 특정 이벤트가 발생했을 때 최상위 요소에서부터 해당 태그를 찾아 내려갑니다.

### 이벤트 버블링(Event Bubbling)

이벤트 버블링은 특정 화면 요소에서 이벤트가 발생했을 때 해당 이벤트가 더 상위의 화면 요소들로 전달되어 가는 특성을 의미합니다. 하위에서 상위 요소로 이벤트 전파. 이벤트 캡쳐와는 반대되는 형태입니다.

### 이벤트 위임(Event Delegation)

하위 요소에 각각 이벤트를 붙이지 않고 상위 요소에서 하위요소의 이벤트들을 제어하는 방식입니다. 예를 들어서 하위요소에 해당하는 target에 이벤트를 걸어주면 새로운 target이 추가되었을 때 이벤트를 새로 등록해줘야합니다. 한 두개면 괜찮은데 새로 추가되는 target이 많아지면 너무 번거로운 작업이 될 것입니다. 이벤트를 걸어줬던 상위요소에 이벤트를 걸어주면 새로운 target이 추가되더라도 일일히 이벤트를 추가 해주지 않아도 이벤트가 잘 먹힐 겁니다.
<br></br>
<br></br>

# Javascript 비동기 처리

자바스크립트의 비동기 처리란? 특정 코드의 연산이 끝날 때까지 코드의 실행을 멈추지 않고 다음 코드를 먼저 실행하는 자바스크립트의 특성을 의미합니다. 자바스크립트에서 비동기 처리가 필요한 이유는 화면에서 서버로 데이터를 요청했을 때 서버가 언제 그 요청에 대한 응답을 줄지도 모르는데 마냥 다른 코드를 실행하지 않고 기다릴 순 없기 때문입니다.

비동기(Asynchronous) 함수란 쉽게 설명하면 호출부에서 실행 결과를 가다리지 않아도 되는 함수입니다. 반대로 동기 함수(Synchronous)는 호출부에서 실행 결과가 리턴될 때 까지 기다려야 하는 함수입니다. 대표적인 비동기 함수라고 한다면 setTimeout()이 있답니다

## 1. callback함수로 비동기 처리 문제점 해결하기

    function userCallback(id, cd){
        const user = {
            id: id,
            name: "User" + id,
        };
        cb(user);
    }

    userCallback(1, function(user)){
        console.log("User:", user);
    };

    //User: {id: 1, name: "User1"}

이렇게 첫번째 파라미터를 넣은 다음에 결과값을 이용해 해야할 작업까지 함수 내부에서 수행해주기 때문에 결과값을 굳이 리턴할 필요가 없습니다.

최근에는 자바스크립트 프로젝트가 점점 더 복잡해지면서 콜백 함수를 인자로 넘겨서 비동기 처리를 하는 스타일을 피하는 추세입니다. 왜냐하면 콜백 함수를 중첩해서 사용하게 되면 계속해서 코드를 들여쓰기 해야하고 그러다보면 코드 가독성이 현저하게 떨어지게 되기 때문입니다. 콜백 지옥이라고 불리는 끔찍한 상황이 일어나니 Promise나 async/await를 이용하는 방법들로 대체되고 있습니다.
<br></br>

## 2. Promise

Promise(프로미스)는 자바스크립트 비동기 처리에 사용되는 객체입니다. 주로 서버에서 받아온 데이터를 화면에 표시할 때 사용합니다.

### 프로미스의 3가지 상태(state)

상태란 프로미스의 처리 과정을 의미합니다. `new Promise`로 프로미스를 생성하고 종료될 때까지 3가지 상태가 있습니다.

- Pending(대기) : 비동기 처리 로직이 아직 완료되지 않은 상태
- Fulfilled(이행) : 비동기 처리가 완료되어 프로미스가 결과 값을 반환해준 상태
- Rejected(실패) : 비동기 처리가 실패하거나 오류가 발생한 상태

<br></br>

✔️ ajax 통신 예제 코드에 프로미스를 적용

    function getData(){
        return new Promise(function(resolve, reject) {
            $.get('url', function(response){
                if(response){
                    resolve(response);
                }
                reject(new Promise("Request is failed"))
            });
        });
    };

    getData().then(function(data){
        console.log(data)
    }).catch(function(err){
        console.log(err)ㅋ
    })

Promise 객체의 `then()`메소드는 결과값을 가지고 수행할 로직을 담은 콜백 함수를 인자로 받습니다. `catch()` 메소드는 예외 처리 로직을 담은 콜백함수를 인자로 받습니다.
<br></br>

## 3. async & await

async & await는 자바스크립트의 비동기 처리 패턴 중 가장 최근에 나온 문법입니다. async가 붙는 함수는 반드시 프라미스를 반환하고 프라미스가 아닌것은 프라미스로 감싸 반환합니다. await는 프라미스가 처리될 때까지 기다리바니다. 결과는 그 이후에 반환됩니다. await는 말 그대로 프라미스가 처리될 때까지 함수 실행을 기다리게 만듭니다. 프라미스가 처리되면 그 결과와 함께 실행이 재개되죠. 프라미스가 처리되길 기다리는 동안엔 엔진이 다른 일(다른 스크립트를 실행, 이벤트 처리 등)을 할 수 있기 때문에, CPU 리소스가 낭비되지 않습니다.

✔️ async & await 예외처리
`try...catch`를 사용해서 처리할 수 있습니다. 프라미스에서 `.catch()`를 사용했던 것 처럼 `catch{}`를 사용하면 됩니다.
<br></br>
<br></br>

# 프론트엔드 빌드 시스템

1. Babel과 폴리필 <br/>
   바벨은 자바스크립트로 결과물을 만들어주는 컴파일러입니다. 참고로 자바스크립트는 프로그래밍 언어의 소스코드를 바로 실행하는 인터프리터언어입니다.
   브라우저마다 사용하는 언어가 다르기 때문에 이런 문제를 해결해 줄 수 있는것이 babel입니다. ES6로 작성한 코드를 모든 브라우저에서 동작하도록 호환성을 지켜줍니다. 이렇게 변화하는 것을 트랜스파일이라고 표현합니다.

- Polyfill(폴리필) <br/>
  무엇을 메꾸는지 보면 브라우저에서 지원하지 않는 코드를 사용가능한 코드 조각이나 플러그인(추가기능)을 의미한다.
  바벨(babel)만 사용한다고 해서 javascript es6 이후의 최신 문법들이 모든 웹 브라우저에 적용되는건 아니다. polyfill은 프로그램이 처음에 시작될 때 현재 브라우저에서 지원하지 않는 함수를 검사해서 각 object의 prototype에 붙여주는 역할을 한다.

2. Node.js란 <br/>
   node.js 는 JavaScript 엔진(V8 Engine)으로 빌드 된 JavaScript 런타임이다.
   JavaScript를 크롬(Chrome)같은 브라우저에서만 쓰는 것이 아닌 브라우저 밖. 즉, 내 컴퓨터에서 다양한 용도로 확장하기 위해 만들어진 것이 바로 Node.js이다.

- JavaScript 엔진(V8 Engine) : 개발자가 작성한 자바스크립트 코드를 해석하고 실행시켜주는 것이 자바스크립트 엔진으로, 가능한 짧은 시간 내에 가장 최적화된 코드를 생성하는 것이 목표, 그 중 V8 은 오픈소스로 구글크롬과 node.js에서 사용
- JavaScript 런타임 : 프로그래밍언어가 구동되는 환경

#### 프론트엔드 개발에 Node.js가 필요한 이유는?

- 최신 스펙으로 개발할 수 있다
- 빌드 자동화 (배포시 파일압축-코드난독화-폴리필 추가하는 작업을 자동화지원해준다.)
- 개발환경 커스텀마이징

3. ESLint란? <br/>
   ESLint 는 ECMAScript코드에서 문제점을 검사하고 더 나은 코드로 정정하는 린트 도구중의 하나이다. 검사하는 항목은 아래와 같다.

   - 포맷팅
   - 코드품질 <br/>
     `포맷팅` 은 일관된 코드 스타일을 유지하도록 하고 개발자들이 쉽게 읽히는 코드를 만들어 준다. <br/>
     `코드품질` 은 어플리케이션의 잠재적인 오류나 버그를 예방하기 위해 사용한다.

4. Prettier란? <br/>
   Prettier는 ESLint에 더하여 코드를 더 예쁘게 만들어 준다. ESLint의 역할 중 포맷팅과 겹치는 부분이 있지만 프리티어는 좀 더 일관적인 스타일로 코드를 다듬는다. 대신 코드품질과 관련된 기능은 하지 않는 것이 ESLint와 다른점이다.
   <br></br>
   <br></br>

# 웹팩이란 모듈 번들러란

## Webpack

프론트엔드 프레임워크에서 가장 많이 사용되는 모듈 번들러입니다. 하나의 웹 서비스를 구성하는 파일을 해석한 다음 하나의 파일로 합쳐주는 역할을 합니다. 웹팩은 자바스크립트만 관계되어 있다고 생각하면 안 됩니다. 웹에서 사용하는 모든 자원에 대해 영향을 미칠 수 있는 강력한 도구입니다.

### 모듈이란?

특정 기능을 갖는 갖은 코드 단위를 의미합니다.

### 모듈 번들링이란?

여러 자원들을 하나의 파일로 병합 및 압축 해주는 동작을 의미합니다.

### 모듈 번들러란?

웹 어플리케이션을 구성하는 HTML,CSS,JS 등을 각각의 모듈로 보고 이를 조합해서 하나의 결과물을 만드는 '주체'입니다.

### 필요한 이유?

1. 여러 파일의 자바스크립트 코드를 압축하여 최적화 할 수 있기 때문에 로딩에 대한 네트워크 비용을 줄일 수 있습니다.
2. 모듈 단위로 개발이 가능하여, 가독성과 유지보수가 쉽습니다
3. 최신 자바스크립트 문법을 지원하지 않는 브라우저에서 사용할 수 있는 코드로 쉽게 변환시켜 줍니다.

물론, 수 많은 자바스크립트 파일이 하나의 파일로 묶인다면 초기 로딩 속도가 커질 수 있습니다. 하지만 웹팩에서는 청크, 캐시, 코드 스플릿 개념들을 도입하면서 이 문제를 해결하고 있습니다.
<br></br>

더 자세히 알아보기(https://joshua1988.github.io/webpack-guide/)
<br></br>
<br></br>

# 웹 접근성과 시맨틱 마크업이란

웹 접근성(web accessibility)은 장애를 가진 사람과 장애를 가지지 않은 사람 모두가 웹사이트를 이용할 수 있게 하는 방식을 의미합니다.
시맨틱 마크업(Semantic Markup)이란 의미를 잘 전달하도록 HTML 문서를 작성하는 것을 말합니다. 시맨틱 마크업을 하기 위해선 우선 각 태그를 용도에 맞게 잘 사용해야합니다. 이외에 CSS 스타일을 명시하는 태그를 사용하지 않는 것 또한 시맨틱 마크업의 한 종류 입니다. 즉, 태그가 가지는 의미 자체가 스타일이라면 이는 마크업 자체가 스타일을 갖는 것이기 때문에 시맨틱 마크업에 적합하지 않습니다.

- 검색엔진이 시맨틱 태그를 중요한 키워드로 간주하기 때문에 검색엔진 최적화(SEO)에 유리합니다
- 웹 접근성 측면에서 시각장애가 있는 사용자로 하여금 그 의미를 훨씬 잘 파악할 수 있습니다.
- 단순한 `div`, `span`으로 둘러싸인 요소들보다 코드를 볼 때 가독성이 훨씬 좋습니다.
  <br></br>
  <br></br>

# 프론트엔드 성능 최적화

프론트 엔드의 성능 최적화에는 총 두가지가 있습니다. 웹 페이지 로드 최적화, 웹 페이지 렌더링 최적화. 이 두가지를 이야기 하기 위해서는 우선적으로 브라우저 동작원리를 아셔야합니다.
아래의 이미지를 참고하시면 됩니다

<img src="https://user-images.githubusercontent.com/35218826/59728727-3553ee80-9276-11e9-9a19-7e6af410a139.jpg" alt="workflow">

1. 웹 페이지 로드 최적화 <br/>

   1. 브라우저 상에서 최적화 <br/>
      html, css파싱을 진행하다가 script 태그와 만나게되면 javscript파싱을 진행하게 되고 그 이후로 동기적으로 파싱이 된다. 그래서 html, css를 파싱하면서 자바스크립트로 인해 block resource가 발생하는걸 방지해야 한다.
   2. 리소스 용량 최적화 <br/>
      리소스 용량을 줄임으로써 리소스 다운로드 시간을 최적화할 수 있다. XHR은 xml http request로 브라우저단에서 서버단으로 HTTP 비동기 통신 할 때 request 가 어떻게 쉉되어 서버로 전달되는지와 서버로부터 요청에 따른 Response 결과를 확인하는 용도이므로 제외한다.
      - 불필요한 코드는 제거한다.
      - 압축 및 난독화로 용량을 최소화 한다.
      - 간결한 셀렉터를 사용한다.
      - 모듈번들러(webpack) css, js 번들링한다.
      - 캐싱할 필요 없는 style은 내부 스타일 시트를 사용한다.

2. 웹 페이지 렌더링 최적화 <br/>
   페이지 렌더링 최적화의 목표는 레이아웃을 최대한 빠르게, 최대한 적게 발생시키는 것입니다.

   1. 레이아웃 최적화
      웹 페이지를 렌더링 하기 위해서는 DOM, CSS가 필요하다. 그러나 다양한 기능과 효과를 구현하기 위해선 자바스크립트를 많이 사용한다. 자바스크립트는 브라우저에서 단일 스레드로 동작하기 때문에 자바스크립트의 실행 시간은 곧 렌더링 성능과 직결된다. 결국엔 자바스크립트에서 실행되는 코드가 최적화 될 수 있게 구성해야 한다.
      <br></br>
      <br></br>

# CORS란

CORS는 Cross-Origin Resource Sharing의 약자입니다. 교차 출처 리소스 공유로 번역될 수 있는데, 브라우저에서 다른 출처의 리소스를 공유하는 방법입니다. 여기서 말하는 출처(Origin)란? URL를 구성하는 Protocal, Host, Port를 합친 것을 이야기합니다.

### CORS 에러 해결 방법

서버에서 Access-Control-Allow-Origin 헤더를 포함한 응답을 브라우저에 보내는 방식으로 CORS 에러를 해결할 수 있습니다. 프론트엔드 개발자가 CORS 에러를 확인했다면, 서버에 Access-Control-Allow-Origin 등 CORS를 해결하기 위한 몇 가지 응답 헤더를 포함해 달라고 요청해야 합니다.

Node.js의 Express는 cors라는 서드 파트 미들웨어를 지원합니다. 이 라이브러리에서 CORS 응답 헤더를 추가해 주기 때문에, 개발자가 별도의 CORS 응답 헤더를 추가해 주지 않아도 됩니다. 다른 프레임워크에서도 CORS를 해결해 주는 라이브러리가 존재합니다.
<br></br>
<br></br>

# MVC 패턴이란

MVC패턴은 디자인패턴 중 하나입니다. 프로그램이나 어떤 특정한 것을 개발하는 중에 발생했던 문제점들을 정리해서 상황에 따라 간편하게 적용해서 쓸 수 있는 것을 정리하여 특정한 "규약"을 통해 쉽게 쓸 수 있는 형태로 만든 것을 말합니다.

MVC는 Model, View, Controller의 약자 입니다. 하나의 애플리케이션, 프로젝트를 구성할 때 그 구성요소를 세가지의 역할로 구분한 패턴입니다.
<br></br>

- 모델 <br/>
  애플리케이션의 정보, 데이터를 나타냅니다. 데이터베이스, 처음의 정의하는 상수, 초기화 값, 변수 등을 뜻합니다. 또한 이러한 데이터, 정보들의 가공을 책임지는 컴포넌트를 말합니다. 뷰나 컨트롤러에 대해서 어떤 정보도 알지 말아야 한다.
- 뷰 <br/>
  input 텍스트, 체크박스 항목 등과 같은 사용자 인터페이스 요소를 나타냅니다. 데이터 및 객체의 입력, 그리고 보여주는 출력을 담당합니다. 데이터를 기반으로 사용자들이 볼 수 있는 화면입니다.
  여러 개의 뷰가 존재할 수 있으며 모델에게 질의하여 데이터를 전달받습니다. 이 때 모델에게 전달받은 데이터를 별도로 저장하지 않아야 합니다.
- 컨트롤러 <br/>
  데이터(모델)와 사용자인터페이스 요소(뷰)들을 잇는 다리역할을 합니다. 즉, 사용자가 데이터를 클릭하고, 수정하는 것에 대한 '이벤트'들을 처리하는 로직 부분을 뜻합니다. 모델이나 뷰에 대해서 알고 있어야합니다. 모델이나 뷰의 변경을 모니터리이하고 있어야합니다.
  <br></br>
  <img src="https://mblogthumb-phinf.pstatic.net/MjAxNzAzMjVfMjUw/MDAxNDkwNDM4NzI4MTIy.4ZtITJJKJW_Nj1gKST0BhKMAzqmMaYIj9PobYJMFD4Ig.xTHT-0qyRKXsA4nZ2xKPNeCxeU2-tLIc-4oyrWq5WBgg.PNG.jhc9639/mvc_role_diagram.png?type=w800" alt="pattern" width="400px"/>
  <br></br>

### 왜 사용할까?

`유지보수의 편리성`
최초 설계를 꼼꼼하게 진행한 시스템이라도 유지보수가 발생하기 시작하면 각 기능간의 결합도(coupling)가 높아지는 경우가 발생합니다. 이런 문제점을 해결하기 위해 UI 시스템의 핵심 컴포넌트를 모델, 뷰, 컨트롤러로 나누고 각 컴포넌트가 자신의 수행 결과를 다른 컴포넌트에게 전달하는 프로그래밍 방식을 만들었습니다. MVC 패턴을 가진 시스템의 각 컴포넌트는 자신이 맡은 역할만 수행한 후 다른 컴포넌트로 결과만 넘겨주면 되기 때문에 시스템 결합도를 낮출 수 있습니다. 유지보수 시에도 특정 컴포넌트만 수정하면 되기 때문에 보다 쉽게 시스템 변경이 가능합니다. (화면의 변경은 only 뷰, 데이터나 비즈니스 요건이 변경은 only 모델, 뷰와 모델 변경에 따른 일부 컨트롤러 변경)
<br></br>
<br></br>

# mvvm 모델이란

모델 - 뷰 - 뷰 모델이라는 3가지 구성으로 이루어진 디자인 패턴입니다.
MVVM 패턴을 사용하면 비즈니스 로직과 프레젠테이션 로직을 UI로부터 깔끔하게 분리할 수 있습니다. 뷰는 UI와 UI 로직을 다루고, 뷰 모델은 프레젠테이션 로직과 뷰를 위한 상태를 다룹니다. 모델은 비즈니스 로직과 데이터를 다룹니다.
뷰와 모델 사이에 뷰 모델이 존재하고 뷰는 뷰 모델을 알지만 뷰 모델은 뷰를 알지 못합니다. 뷰 모델은 모델을 알지만 모델은 뷰 모델을 알지 못합니다. 이런 구조를 통해서 서로 독립적인 형태를 만들어서 위에서 말한 로직들을 분리해서 목적을 이루는 것입니다.
<br></br>
<br></br>

# Array와 LinkedList 차이점

- Array

  - 논리적 저장순서와 물리적 저장 순서가 일치합니다.
  - 인덱스로 해당 원소에 접근이 가능합니다.
  - 배열의 원소를 삭제할 경우 삭제한 원소보다 큰 인덱스를 가진 원소들의 위치를 옮겨줘야합니다.
  - 삽입의 경우, 새로운 원소를 추가하고 모든 원소들의 인텍스를 1씩 올려줘야합니다..
  - 제한적인 크기를 갖습니다.

- LinkedList
  - 자료의 주소 값으로 노드를 이용해 서로 연결되어 있는 구조
  - 사입과 삭제의 경우 Array보다 속도가 빠르다고 하지만 엄밀히 말하자면 경우에 따라서 다릅니다.
  - 원하는 값을 찾기 위해서 최소 한 번은 리스트를 순회하여야 하므로 시간 복잡도를 갖습니다.
  - 트리의 근간이 되는 자료구조입니다.

### 차이점

- 데이터 접근 속도
  - Array는 인덱스를 사용해 빠르게 원소에 접근할 수 있다. 따라서 시간 복잡도 O(1)로 빠르게 찾을 수 있습니다.
  - LinkedList는 순차 접근 방식을 사용하기 때문에 특정 원소에 도달하려면 처음부터 순차적으로 검색하며 찾습니다. 그래서 시간 복잡도 O(N)
- 데이터의 삽입 속도
  - 경우에 따라서 다른데, 배열의 경우 데이터 중간이나 맨 앞에 삽입할 경우, 원래 있던 데이터 위치를 변경해줘야하기때문에 추가 과정에 시간이 소요됩니다. 데이터가 많을 경우는 비효율적입니다.
  - LinkedList는 어느 곳에 삽입을 하던지 삽입할 위치를 찾고 삽입 연산을 진행하기 때문에 다소 시간이 걸리지만 배열보다 빠른 성능을 보입니다.
- 데이터 삭제 속도
  - 배열은 해당 요소를 삭제 후 원 요소들의 위치를 이동해줘야합니다.
  - LinkedList는 삭제할 원소를 찾기 위해서 시간이 걸립니다. 하지만 배열보다는 빠르게 삭제 연산을 수행합니다.
- 메모리 할당
  - 배열은 선언되자마자 complie time에 할당되어집니다. 이걸 정적 메모리 할당이라고 합니다. Stack영역에 메모리 할당이 이루어 집니다.
  - LinkedList는 새로운 node가 추가 될 때 runtime에 할당되어집니다. 이것을 동적 메모리 할당이라고 합니다. Heap영역에 할당되어집니다.
- Size
  - 배열은 반드시 선언시점에 지정됩니다. LinkedList는 node가 추가될 때 runtime시점에서 사이즈가 커질 수가 있어서 다양합니다.

### 삽입과 삭제가 빈번하다면 LinkedList를 사용하는 것이 더 좋고 데이터의 접근하는 게 중요하다면 Array를 사용하는 것이 좋습니다.

<br></br>
<br></br>

# 타입스크립트란

타입스크립트는 자바스크립트에 타입을 부여한 언어로 자바스크립트의 확장된 언어라고 볼 수 있습니다.
TypeScript는 MS에 의해 개발/관리되고 있는 오픈소스 프로그래밍 언어로 대규모 어플리케이션을 개발하는데 자바스크립트가 어렵고 불편하다는 불만에 대응하기 위해 개발되었습니다. 기존의 자바스크립트 문법을 그대로 사용할 수 있고 ES6의 새로운 기능들을 사용하기 위해서 바벨과 같은 별도 트랜스파일러를 사용하지 않아도 기존의 자바스크립트 엔진(브라우저 혹은 노드)에서 실행할 수 있습니다.

<img src="https://t1.daumcdn.net/cfile/tistory/9959A43359E3026B10" alt="typeScript" width="300px" />

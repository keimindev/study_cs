# FrontEnd common sense

- [함수형 프로그래밍이란?](#함수형-프로그래밍이란?)
- [브라우저 저장소](#브라우저-저장소)
- [브라우저 동작 원리](#브라우저-동작-원리)
- [Virtual DOM이란? 썼을 때 장점](#Virtual-DOM)
- [Javascript의 this](#Javascript의-this)
- [Javascript event](#Javascript-event)
  (이벤트 캡처링 & 버블링, 이벤트 위임방식)
- [Javascript 비동기 처리](#Javascript-비동기-처리)
  (콜백, 프로미스, async-await)
- 프론트엔드 빌드 시스템
- 웹팩이란? 모듈 번들러가 무엇인가
- “기획 - 디자인 - API 개발 - 프런트엔드 개발”의 서비스 절차에서 프런트엔드 개발자의 역할은 무엇이라고 생각하는지?
- CORS란? CORS를 해결하기 위한 방법
- 프런트엔드 성능 최적화란?
- 웹 서비스 배포 시스템 구축시 CI, CD가 무엇인가?
- 웹 접근성과 시맨틱 마크업이란?

<br></br>
<br></br>
<br></br>

# 함수형 프로그래밍이란?

함수형 프로그래밍이란 하나의 선언형 프로그래밍 파러다임으로 정의되는 일련의 코딩 접근 방식입니다. 순수 함수를 조합하고 스프트웨어를 만드는 방식이라고 말할 수 있습니다.

순수 함수(pure function) 를 조합하고 공유 상태(shared state), 변경 가능한 데이터(mutable data) 및 부작용(side-effects) 을 피하여 소프트웨어를 만드는 프로세스다.명령형(imperative) 이 아닌 선언형(declarative) 이며 애플리케이션의 상태는 순수 함수를 통해 전달됩니다.
<br></br>
<br></br>

# 브라우저 저장소

### Web Storage

web storage란 HTML5부터 제공하는 기능으로 해당 도메인과 관련된 특정 데이터를 서버가 아니라 클라이언트 웹 브라우저에 저장할 수 있도록 제공하는 기능이다. 이와 비슷한 기능으로 쿠키(cookie)가 있다.

key/value 형태로 데이터를 저장하고 key를 기반으로 데이터를 조회하는 방식이다. 영구저장소라 불리기도 하는 LocalStorage와 임시저장소라 불리는 SessionStorage 두 곳이 있다. 데이터의 지속성을 구분할 수 있어 응용 환경에 맞는 선택이 가능하다.

web storage는 쿠키와 마찬가지로 사이트의 도메인 다윈로 접근이 제한된다. 예를 들면 A사이트에 저장한 데이터는 B사이트에서는 조회할 수 없다. 보안측면을 보자면 당연하다.

### 그렇다면 쿠키라는 것도 있는데 왜 web storage가 필요한가?

세가지 모두 브라우저에 저장되만 쿠키는 web storage와 비교해서

- 4KB의 데이터 저장 제한
- HTTP Request에 암호화 되지 않은 상태로 사용하기때문에 보안에 취약
- 쿠키는 모든 HTTP Request에 포함되어 웹 서비스 성능에 영향을 줄 수 있다

이런 차이가 있다.
<br></br>
이제 web storage가 쿠키에 비해서 가지는 강점에 대해 이야기해보자
쿠키는 매번 서버로 전송이 된다.

- web storage는 저장된 데이터가 클라이언트에 존재할 뿐 서버로 전송되지는 않는다. 이는 네트워크 트래픽 비용을 줄여준다.
- web storage는 문자열 기반 데이터 외에 체계적으로 구조화된 객체를 저장할 수 있다
- web storage는 용량의 제한이 없다. 클라이언트 최대 300개의 쿠키를 저장할 수 있고 용량이 제한되어있다.
- web storage는 영구 데이터 저장이 가능하다. 쿠키는 만료일자를 지정하게 되어있어 언젠가 제거된다. 만약에 만요일자를 지정하지 않으면 세션쿠키가 된다.

<br></br>
✔️ 세션쿠키(Session Cookie)
활성 웹 브라우저 세션이 있는 기간동안 저장된다. 세션쿠키는 일반적으로 웹 브라우저를 닫을 때 삭제된다.
<br></br>

### Web Storage

1. LocalStorage - 브라우저를 닫았다가 다시 열어도 계속 유지된다. 도메인마다 별도로 생성된다.
2. SessionStorage - 브라우저가 열려있는 한 페이지를 reload해도 계속 유지된다. 하지만 브라우저를 닫으면 삭제된다. 같은 사이트의 같은 도메인이라도 브라우저가 다르면 서로 다른 영역이 된다.
   <br></br>
   <br></br>

# 브라우저 동작 원리

브라우저가 HTML을 전달 받으면, 곧 이를 변환(파싱)하고 노드들로 이루어진 DOM 트리를 만든다. 이후 외부의 CSS파일과 각 노드들의 inline 스타일을 파싱하여 스타일을 입힌 Render트리를 만든다. Render트리가 만들엊면 각 노드들이 화면에서 정확히 어디에 나타나야 하는지에 대한 위치가 주어진다. 그 후, paint() 메서드를 호출하면 내가 구현하고 싶었던 화면이 출력된다. DOM은 해당 과정을 계속 반복한다.

- DOM Tree 생성 - Render Tree 생성 - Layout - Paint

<br></br>
현재 대부분의 웹사이트는 수 십개 혹은 수 백개의 페이지로 이루어져있다. 오타 하나를 잡고 싶을 뿐인데, 전체 사이트를 다시 처음부터 렌더링을 해야 하며, 그 수정할 부분을 찾는 시간도 많이 걸려서 굉장히 비효율적이다. 이 부분을 타파하기 위해서 Virtual DOM이 나왔다.
<br></br>
<br></br>
<br></br>

# Virtual DOM

텍스트 파일로 만들어진 웹 문서를 브라우저에 렌더링하기 위해서 브라우저가 이해할 수 있는 구조로 변환하는걸 파싱한다고 한다. 이때 브라우저가 이해할 수 있는 구조를 DOM이라고 볼 수 있다.

DOM(Document Object Model)이란 ? HTML, XML document와 상호작용하고 표현하는 API이다. DOM은 browser에서 로드되며 Node트리로 표현하는 document 모델이다. 웹 페이지의 형태를 정적이며 이를 동적으로 변경하기 위해 DOM은 프로그래밍 언어가 자신에게 접근하고 수정할 수 있도록 DOM API를 제공했고 일반적으로 자바스크립트로 제공한다.

Virtual DOM(가상 DOM)은 DOM의 변경사항에 대해서 DOM에서 수행해야 할 모든 변경 사항을 Virtual DOM(가상 DOM)에서 수행한 다음에 실제 DOM에 전달해준다. 그래서 수정사항이 여러 가지 있더라도, 가상 DOM은 한 번만 렌더링을 일으킨다. 다시 말하자면 가상 DOM은 DOM이 생성되기 전, 이전 상태 값과 수정사항을 비교하여 달라진 부분만 DOM에게 한 번에 전달하여 딱 한번만 랜더링이 되게 한다.

Virtual DOM(가상 DOM)은 개발자가 작업을 보다 쉽게 할 수 있도록 도와주는 것이지, 가상돔에서 더 빠르게 접근할 수 있는 무언가를 제공해 주는 것이 아니다. 실제로 vanila.js가 가상돔에서 작업하는 것보다 항상 더 빠르다고 한다. 가상돔은 목적을 위한 수단일 뿐이라는 점을 기억하자!
<br></br>
<br></br>

# Javascript의 this

javascript에서 함수의 this의 값은 함수를 호출하는 방법에 의해 결정된다. 실행하는 동안의 할당에 의해 설정될 수 없고, 함수가 호출될 때 마다 다를 수 있다. ES5에는 함수의 this 값이 함수가 어떻게 호출되었는지 개의치 않고 설정할 수 있는 bind 메소드가 있다.

바인딩이란? this의 호출 방식에 따라서 this가 특정 '객체'에 연결되는 것이다. this 바인딩은 일반 함수 내부, 메소드 내부, 생성자 함수 내부, Call, Apply, Bind 를 통한 '호출 방식'으로 나눠서 볼 수 있다.

- 일반 함수 내부에서의 this는 글로벌 객체와 바인딩된다.
- 메서드 내부에서의 this는 메서드를 호출한 객체와 바인딩된다.
- 생성자 함수 내부에서 this는 생성자 함수가 생성할 인스턴스와 바인딩된다.
- call, apply, bind 메서드 사용시 메서드에 첫번째 인수로 전달하는 객체에 바인딩 된다. <br>
  [자세히 보러가기]

this는 함수 호출 방식에 따라서 동적으로 결정된다.
<br></br>
<br></br>

# Javascript event

### 이벤트 캡쳐(Event Capture)

이벤트 캡쳐는 클릭 이벤트가 발생한 지점을 찾아 내려가는 이벤트 전파 방식입니다. 특정 이벤트가 발생했을 때 최상위 요소에서부터 해당 태그를 찾아 내려갑니다.

### 이벤트 버블링(Event Bubbling)

이벤트 버블링은 특정 화면 요소에서 이벤트가 발생했을 때 해당 이벤트가 더 상위의 화면 요소들로 전달되어 가는 특성을 의미합니다. 하위에서 상위 요소로 이벤트 전파. 이벤트 캡쳐와는 반대되는 형태입니다.

### 이벤트 위임(Event Delegation)

하위 요소에 각각 이벤트를 붙이지 않고 상위 요소에서 하위요소의 이벤트들을 제어하는 방식입니다. 예를 들어서 하위요소에 해당하는 target에 이벤트를 걸어주면 새로운 target이 추가되었을 때 이벤트를 새로 등록해줘야합니다. 한 두개면 괜찮은데 새로 추가되는 target이 많아지면 너무 번거로운 작업이 될 것입니다. 이벤트를 걸어줬던 상위요소에 이벤트를 걸어주면 새로운 target이 추가되더라도 일일히 이벤트를 추가 해주지 않아도 이벤트가 잘 먹힐 겁니다.
<br></br>
<br></br>

# Javascript 비동기 처리

자바스크립트의 비동기 처리란? 특정 코드의 연산이 끝날 때까지 코드의 실행을 멈추지 않고 다음 코드를 먼저 실행하는 자바스크립트의 특성을 의미합니다. 자바스크립트에서 비동기 처리가 필요한 이유는 화면에서 서버로 데이터를 요청했을 때 서버가 언제 그 요청에 대한 응답을 줄지도 모르는데 마냥 다른 코드를 실행하지 않고 기다릴 순 없기 때문입니다.

비동기(Asynchronous) 함수란 쉽게 설명하면 호출부에서 실행 결과를 가다리지 않아도 되는 함수입니다. 반대로 동기 함수(Synchronous)는 호출부에서 실행 결과가 리턴될 때 까지 기다려야 하는 함수입니다. 대표적인 비동기 함수라고 한다면 setTimeout()이 있답니다

## 1. callback함수로 비동기 처리 문제점 해결하기

    function userCallback(id, cd){
        const user = {
            id: id,
            name: "User" + id,
        };
        cb(user);
    }

    userCallback(1, function(user)){
        console.log("User:", user);
    };

    //User: {id: 1, name: "User1"}

이렇게 첫번째 파라미터를 넣은 다음에 결과값을 이용해 해야할 작업까지 함수 내부에서 수행해주기 때문에 결과값을 굳이 리턴할 필요가 없습니다.

최근에는 자바스크립트 프로젝트가 점점 더 복잡해지면서 콜백 함수를 인자로 넘겨서 비동기 처리를 하는 스타일을 피하는 추세입니다. 왜냐하면 콜백 함수를 중첩해서 사용하게 되면 계속해서 코드를 들여쓰기 해야하고 그러다보면 코드 가독성이 현저하게 떨어지게 되기 때문입니다. 콜백 지옥이라고 불리는 끔찍한 상황이 일어나니 Promise나 async/await를 이용하는 방법들로 대체되고 있습니다.
<br></br>

## 2. Promise

Promise(프로미스)는 자바스크립트 비동기 처리에 사용되는 객체입니다. 주로 서버에서 받아온 데이터를 화면에 표시할 때 사용합니다.

### 프로미스의 3가지 상태(state)

상태란 프로미스의 처리 과정을 의미합니다. `new Promise`로 프로미스를 생성하고 종료될 때까지 3가지 상태가 있습니다.

- Pending(대기) : 비동기 처리 로직이 아직 완료되지 않은 상태
- Fulfilled(이행) : 비동기 처리가 완료되어 프로미스가 결과 값을 반환해준 상태
- Rejected(실패) : 비동기 처리가 실패하거나 오류가 발생한 상태

<br></br>

✔️ ajax 통신 예제 코드에 프로미스를 적용

    function getData(){
        return new Promise(function(resolve, reject) {
            $.get('url', function(response){
                if(response){
                    resolve(response);
                }
                reject(new Promise("Request is failed"))
            });
        });
    };

    getData().then(function(data){
        console.log(data)
    }).catch(function(err){
        console.log(err)ㅋ
    })

Promise 객체의 `then()`메소드는 결과값을 가지고 수행할 로직을 담은 콜백 함수를 인자로 받습니다. `catch()` 메소드는 예외 처리 로직을 담은 콜백함수를 인자로 받습니다.
<br></br>

## 3. async & await

async & await는 자바스크립트의 비동기 처리 패턴 중 가장 최근에 나온 문법입니다. async가 붙는 함수는 반드시 프라미스를 반환하고 프라미스가 아닌것은 프라미스로 감싸 반환합니다. await는 프라미스가 처리될 때까지 기다리바니다. 결과는 그 이후에 반환됩니다. await는 말 그대로 프라미스가 처리될 때까지 함수 실행을 기다리게 만듭니다. 프라미스가 처리되면 그 결과와 함께 실행이 재개되죠. 프라미스가 처리되길 기다리는 동안엔 엔진이 다른 일(다른 스크립트를 실행, 이벤트 처리 등)을 할 수 있기 때문에, CPU 리소스가 낭비되지 않습니다.

✔️ async & await 예외처리
`try...catch`를 사용해서 처리할 수 있습니다. 프라미스에서 `.catch()`를 사용했던 것 처럼 `catch{}`를 사용하면 됩니다.

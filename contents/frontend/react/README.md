# React

- [react 클래스형과 함수형의 차이는?](#react-클래스형과-함수형의-차이점)
- [라이브러리와 프레임워크의 차이점](#라이브러리와-프레임워크의-차이점은)
- [Vue와 React의 차이점](#Vue와-React의-차이점)
- [Angular와 React의 차이점](#Angular와-React의-차이점)
- [ContextAPI](#ContextAPI)
- [Redux가 무엇인가요?](#Redux가-무엇인가요)
- [Client Side Rendering vs Server Side Rendering](#CSR-vs-SSR)
- [React component 생명주기란?](#React-component-생명주기란?)
- [state랑 props 차이점](#state랑-props-차이점)
- [Props drilling](#Props-drilling)
- [useState vs useEffect](#useState-vs-useEffect)
- [React Hooks](#react-hooks)
- [Next.js에서 Static Generation과 Server-side Rendering의 차이점](#Next.js에서-Static-Generation과-Server-side-Rendering의-차이점)
- [Next.js 사용하는 이유](#Next.js-사용하는-이유)


<br></br>
<br></br>
<br></br>
<br></br>

# react 클래스형과 함수형의 차이점

2019년 v16.8 부터 함수형 컴포넌트에 리액트 훅(hook)을 지원해 주어서 현재는 공식 문서에서도 함수형 컴포넌트와 훅(hook)을 함께 사용할 것을 권장하고 있습니다.
크게 선언방식이 다르고 state를 이용하는 방식, props를 사용하는 방식에 차이가 있습니다.

- 클래스형

1. class 키워드 필요
2. Component로 상속을 받아야한다.
3. render() 메소드가 반드시 필요하다.
4. state, lifeCycle 관련 기능사용이 가능하다.
5. 함수형보다 메모리 자원을 더 사용한다.
6. 임의 메소드를 정의할 수 있다.
7. constructor 안에서 this.state 초기 값 설정 가능
8. counstructor 없이도 바로 state 초기값을 설정 가능
9. this.setState() 를 통해 state값을 변경
10. 클래스형의 state는 객체형식
11. 함수선언시 화살표 함수로 바로 가능하고, 요소를 적용할 때는 꼭 this를 써야합니다
12. props 호출시에도 this를 붙여서 써야한다.

- 함수형

1. state, lifeCycle 관련 기능사용 불가능하다. [Hook을 통해 해결]
2. 클래스형보다 메모지 자원을 덜 사용한다.
3. 컴포넌트 선언이 편하다.
4. useState 함수로 state를 사용한다.
5. useState 함수를 호출하면 배열이 반환되는데 첫 번째 원소는 현재 상태, 두번째 원소는 상태를 바꿔주는 함수이다.
6. const + 함수 형태로 선언해야하고 this를 쓸 필요가 없습니다.
7. props는 그냥 바로 호출할 수 있다
   <br></br>
   <br></br>

# 라이브러리와 프레임워크의 차이점은

라이브러리는 사용자가 필요할 때 가져다 썼다가 뺐다가 할 수 있고 부분적으로 사용이 가능하다. 프레임워크는 부분적 사용이 불가능하고 프레임 워크 안으로 들어가서 프레임워크가 지원해주는 문법에 따라서 작성해줘야 제대로 동작한다.
<br></br>
<br></br>

# Vue와 React의 차이점

Vue는 오픈소스 자바스크립트 프레임워크고 React는 라이브러리다.
공톰점이 있다면 둘다 컴포넌트 기반에 virtual dom 방식이라 가볍고 빠르다는 점입니다.

- React는 React만의 대체 불가능한 문법이 지정되어있기 보다는 자바스크립트 문법을 응용해서 개발자가 자유롭게 개발할 수 있는 환경이고, Vue는 Vue에서 지정해준 문법 방식으로만 개발 할 수 있다.
- Vue는 Vue에서 제공해주는 문법으로만 코딩이 가능하기 때문에 개발자간에 코딩 스타일에도 통일성이 생기는데, React는 자유도가 높아서 개발자마다 코딩 스타일을 통일하는데 커뮤니케이션 비용이 듭니다.
- 템플릿 방식으로 관리하는 Vue와는 달리, React는 JSX 코드로 컴포넌트를 작성하고 컴포넌트의 상태(State)를 변화시키지 않고 관리합니다. 변화가 일어나면 실제 브라우저의 DOM에 새로운 것을 적용하는 것이 아니라, 자바스크립트로 이루어진 Virtual DOM에 렌더링을 하고 기존의 DOM과 비교하여 변화가 일어난 곳만 업데이트 합니다.
  템플릿은 재구조화가 어렵고, 에러에 취약하지만, React는 상태를 고유 속성대로 유지하기 때문에 대규모 프로젝트에서도 관리가 수월하고 테스트에도 적합합니다.

<br></br>
<br></br>

# Angular와 React의 차이점

Angular 는 타입스크립트 기반 오픈소스 프레임워크이고 React는 라이브러리다.

- Angular에서는 일반적으로 HTML, SCSS, TS 파일을 따로 분리하여 컴포넌트를 개발합니다.
  라우팅, 상태관리, 폼 유효성 등 필요한 도구를 모아놓은 All In One 프레임워크인 것이 큰 장점
  가볍고 빠르게 작업을 해야하는 프로젝트 보다는 큰 프로젝트에 사용하기 적합하다.
  TypeScript를 기반으로 하기 때문에 엄격하지만 그만큼 직관적이고 오류를 줄일 수 있지 않을 까 생각한다.
- React는 JSX 문법과 Styled Components 라이브러리를 사용하여 오직 Javascript만으로 컴포넌트를 개발하는 것이 대세입니다. 장점은 virtual dom이다. Dom 트리를 추상화하여 자바스크립트 객체로 만들어 두고 변경되는 부분은 virtual dom에서 처리하여 성능을 높혔다.
  SPA(Single Page Application) 방식으로 진행한다면 검색엔진 노출(SEO : Search Engine Optimization)에 관련된 문제를 생각 했을 때 SSR을 염두해 둘 수 밖에 없었는데 Next.js를 사용하여 해결 할 수 있다. 그리고 UI를 구성하는 개별적인 뷰 단위인 컴포넌트 단위로 작성하여 생산성과 유지보수에 도움이 된다
  <br></br>
  <br></br>

# ContextAPI

리액트 내에서 전역적으로 상태를 관리하기 위한 기능입니다. 리액트는 props와 state로 데이터 전달과 관리를 합니다. 수로 상위에서 하위로 데이터가 흘러가지만 때로는 하위에서 상위로 올라가야 할 때도 있습니다. 이런 문제를 해결하기 위해서 context 라는 것이 있습니다. <br/>
부모 컴포넌트로부터 자식 컴포넌트로 전달되는 데이터의 흐름과 상관없이 전역적인 데이터를 다룰 때 사용합니다. context에 저장된 데이터를 사용하기 위해서 contextAPI를 이용해야합니다. Context의 Provider를 사용하여 데이터를 제공해야 하며, 데이터를 사용하려는 컴포넌트에서 Context의 Consumer를 사용하여 실제로 데이터를 사용합니다.

<br></br>
<br></br>

# Redux가 무엇인가요

컴포넌트끼리 props로 데이터를 넘겨주는 방식의 리액트에서 부모와 자식 컴포넌트 간에 props를 넘길 때 문제가 생길 수가 있습니다. `Redux`는 이럴때 유용하게 쓸 수 있는 것으로 전역상태관리를 하기 위한 라이브러리입니다. 하나의 store를 컴포넌트 밖에 두고 리액트 전역으로 데이터를 전해줄 수 있는 방식입니다.

동일한 데이터는 한 store에서 가져오고 액션이라는 객체를 통해서 상태를 변경할 수 있습니다.순수함수로만 가능하고. 불변성으로 원본값이 변하지는 않습니다. 유지보수에 용이하고, 리액트 프로젝트에서 데이터를 전역으로 관리해야할 때 유용하게 사용할 수 있습니다.

상태 관리가 되는 오직 하나의 공가 store가 있고, 스토어로 운반할 자바스크립 객체 형식의 데이터인 action이 있고, 그 action을 받아서 store로 전달하기 위한 reducer가 있습니다. dispatch()를 써서 action이 전달한 주문을 reducer가 보고 store로 상태를 업데이트합니다.
  

<br></br>
<br></br>

# CSR vs SSR

### Client Side Rendering

HTML을 반환 한 후에 자바스크립트만 동작하면서 데이터만 주고 받아서 렌더링을 진행하는 방식
싱글 페이지 어플리케이션이라고도 한다.

#### 장점

- 첫 요청시 한 페이지만 불러온다. 그 이후 필요한 부분만 랜더링해서 읽기에 빠른 인터렉션을 기대할 수 있다.
- 페이지 로딩시 중요하지 않은 리소스의 로딩을 늦춘다.

#### 단점

- 초기 구동속도가 상당히 느리다.
  <br></br>

### Server Side Rendering

서버에서 랜더링 작업하는 방식으로 사용자가 웹 페이지에 접근할 때 서버에 각각의 페이지에 대한 요청을 하며 서버에서 HTML, JS파일 등을 다 다운로드해서 화면에 랜더링하는 방식

#### 장점

- 검색엔지 최적화(SEO) 가능
- 첫 랜딩된 HTML을 client에게 전달해주기때문에 초기 로딩속도를 많이 줄일 수 있다.

#### 단점

- 페이지 이동시 화면이 깜빡 거린다.
- 서버 랜더링에 따른 부하가 발생한다.
- 페이지 요청마다 페이지 새로고침이 발생한다.


<br></br>
<br></br>


# React component 생명주기란?

`componentDidMount()`, `componentDidUpdate()`, `componentWillUnMount()`으로 컴포넌트가 생성, 마운트되고 업데이트되고, 그 후에 언 마운트되어 제거되는 순으로 일어납니다. 그 안에 포함되어있는 contructor(),render()등의 메서드들이 있습니다. 함수형에서는 useEffect()를 이용해서 생명주기 메소드를 사용할 수 있습니다. `componentDidMount()`,`componentDidUpdate()`, `componentWillUnMount()` 혼합되어있다고 보면됩니다. useEffect()에서 선언을 하면 렌더링될 때마다 실행이 되는데, update 되었을 때 호출하고 싶다면 특정값을 의존값을 배열로 넣어줍니다. 이게 componentDidUpdate와 유사합니다. 이후에 return 을 넣어서 unmount 해주면 됩니다.

<br></br>
<br></br>


# Virtual DOM

DOM은 웹페이지나 웹 앱에 있는 HTML을 구조적으로 표현한 것으로 전체적인 ui를 나타내며 트리 데이터 구조로 표현됩니다. 리액트는 가상돔을 사용하는데, 실제 돔을 조작하는 방식이 아니라 실제 돔을 카피한 가상 돔에 구성해서 원래 돔이랑 비교후 달라진 부분만 리렌더링 해주는 방식으로 동작합니다. 실제 돔은 브라우저가 화면을 그리는데 필요한 모든 정보를 가지고 있기 때문에 무겁게 동작합니다. 그래서 리액트는 부드러운 ux를 제공하기 위해 변경사항만 빠르게 파악하고 리렌딩하는 방식으로 움직입니다. 이때 리액트는 불변성을 지켜줘야하기 때문에 객체의 원복을 수정하지 않고 상태 변경을 원하는 부분만 복사하고 사용해야합니다. 예를 들어 배열을 수정한다고 했을 때 push().pop()와 같은 메소드를 바로 사용해서 원복을 수정하는 것이 아니라 복수후에 그 값을 수정해서 state에 반영합니다. 


<br></br>
<br></br>


# state랑 props 차이점

`props`는 데이터의 흐름을 부모에서 자식으로 상위 개념에서 하위개념으로 보내며 관리한는 것, 즉 컴포넌트가 외부에서 받는 데이터입니다. `state`는 컴포넌트 내부에서 관리하는 데이터를 말합니다. `props`는 읽기 전용이기 때문에 직접 수정을 할 수는 없습니다. 컴포넌트간에 데이터를 전달하는데 사용합니다.


<br></br>
<br></br>

# Props drilling 

props를 오로지 하위 컴포넌트로 전달하는 용도로만 쓰이는 컴포넌트들을 거치면서 React Component 트리의 한 부분에서 다른 부분으로 데이터를 전달하는 과정입니다. 값 추적이 용이하다는 장점이 있습니다. 하지만 10 - 15개씩의 컴포넌트로 늘어난다면 그 과정이 너무 불편하고, 누락될 수 있다는 단점이 있습니다. 게다가 중간에 필요없는 컴포넌트에도 전달해야할 수 도 있습니다. contextAPI, redux같은 상태관리 라이브러리를 사용하면 됩니다. 

<br></br>
<br></br>

# useState vs useEffect

`useState()`는 함수형 컴포넌트에서 상태값을 관리할 때 쓰는 것으로 데이터를 담는 그릇이라고 보면 좋을 것 같습니다. 데이터를 함수 안에서 사용하기 위해서 state에 담고 setState를 이용해 업데이트 시켜주고 합니다. `useEffect()`는 컴포넌트 상태값 변화에 따라서 컴포넌트 내부에서 변경되야 할 값들을 처리해주는 것으로 함수가 실행되면서 함수 외부에 존재하는 값이나 상태를 변경시키는 등의 행위를 합니다. 리액트 클래스 컴포넌트에서 사용되는 생명주기를 useEffect를 통해서 할 수 있습니다. 

<br></br>
<br></br>

# react hooks

`useState` 컴포넌트 내부에서 state 상태를 관리하기 위해 사용한다. 

`useEffect` 컴포넌트 상태값 변화에 따라서 컴포넌트 내부에서 변경되야 할 값들을 처리해주는 것으로 함수가 실행되면서 함수 외부에 존재하는 값이나 상태를 변경시키는 등의 행위를 합니다.

`useLayoutEffect` 브라우저가 화면에 DOM을 그리기 전에 실행. useEffect와 형태는 같지만 돔의 레이아웃배치와 페이트가 끝난 후 호출. DOM에 반영이 안 된 때 기본 형태가 표출되었다가 업데이트 됨. 

`useMemo` 성능최적화를 위하여 연산된 값을 재사용 할 때 쓰는 방법. 값을 캐싱 memoized 를 의미. 어떠한 의존성을 가진 함수가 있다고 했을 때, 이 값이 업데이트 되면 처음부터 다시 렌더링할 게 아니라 memo를 쓰며 그 값만을 가지고 렌더링을 한다. 

`useRef` 특정 돔 요소에 접근하여 불필요한 재렌더링을 막을 때 사용합니다. 초기값을 변수명에 넣어줘야함. 렌더링과 상관없이 컴포넌트가 언 마운트하기 전까지 계속 값을 그대로 유지한다. 

`useCallback ` 이미 생성된 함수를 반환하는 리액트 훅입니다. 특정 함수를 새로 만들지 않고 재사용하고 싶을 때 사용합니다. 리액트 대표 메모이제이션 중에 하나로 useCallback, useMemo. usecallback을 안쓰면 함수는 컴포넌트가 렌더링 될 때마다 새롭게 생성이 될 것입니다. usecallback을 쓰고 의존값을 주면 그 상태가 변하지 않는 한 다시 생성되지 않습니다. 성능 향상시키고 코드의 복잡성을 줄일 수 있다. 


<br></br>
<br></br>


# Next.js에서 Static Generation과 Server-side Rendering의 차이점

정적 생성방식  vs 서버사이드 렌더링으로 정적생성방식은 html를 빌드시간에 생성하며 생성된 html을 여러 요청에 대해 재사용하도록 합니다. 서버사이드 렌더링은 정적 생성 방식과 달리 html 을 빌드시간이 아닌 매 요청마다 생성하며 응답하는 방식입니다. 매번 요청마다 페이지가 생성되므로 정적생성보다는 느리지만 항상 최신 상태를 유지할 수 있습니다. 예를 들어서 외부 데이터를 계속해서 사용하며 해당 데이터가 사용자 요청에 따라서 변동될 가능성이 높은면 서버사이드 렌더링을 하는 게 맞고, 외부 데이터를 불러올 필요없거나 필요하더라도 해당 데이터가 변하지 않는 형태로 최초에 한번만 불러오면 되는거면 정적 생성방식이 더 적합합니다. 


<br></br>
<br></br>


# Next.js 사용하는 이유

client-side rendering은 브라우저에서 html을 실시간으로 만드는 방법이고 server-side rendering은 서버에서 html을 미리 만들어 보내줍니다. client-side rendering 사용시 예쁘고 부드러운 움직임의 사이트는 만들 수 있는데 첫 페이지 로딩속도저하, 검색노출 어려움 같은 단점이 있어서 웹사이트의 bounce rate 지표들이 낮아지고 트래픽 잡으려고 광고비도 많이 들고 그래서 투자대비 수입 지표가 낮아질 수 밖에 없습니다. server-side rendering을 사용하는 경우 서버에서 html을 미리 만들어주기 때문에 위의 단점들이 사라지는 경우가 많습니다. 

- 폴더기반 자동라우팅
- 새로 디자인한 서버API 기능
- 쉬운 DB연결
- 직관적인 rendering 전략 선택기능 
- hydration없는 server-side rendering


<br></br>
<br></br>

